## 1장 SQL 처리 과정과 I/O
### 1.1 SQL 파싱과 최적화
+ SQL 실행 과정
	1. SQL 파싱
		+ SQL 파서가 SQL 파싱을 하면서 문법 및 의미 오류 검사를 한다.
			+ Syntax 체크(문법 검사) : 문법적 오류가 없는지 확인하다.
			+ Semantic 체크(의미 검사) : 의미상 오류가 없는지 확인한다. 존재하지 않은 테이블이나 컬럼을 사용했는지 등등
	2. 옵티마이저 SQL 최적화
		+ 옵티마이저는 다양한 실행경로를 생성해서 가장 효율적인 방법을 선택한다.
	3. 로우 소스 생성 및 실행
		+ 옵티마이저의 실행 계획을 기반으로 SQL 실행하고 실행 계획을 라이브러리 캐시(Library Cache)에 저장한다.

> 로우 소스
> + SQL 실행 계획에서 각 작업 단계를 말한다.

+ SQL 옵티마이저 최적화 과정
	1. SQL에서 후보군이 될만한 실행계획을 찾아낸다.
	2. 각 실행계획의 예상 비용을 산정한다.
	3. 최저 비용을 나타내는 실행 계획을 선택한다.
+ 옵티마이저 힌트
	+ 주석 기호에 +를 붙이면 된다.
	```sql
	/*+ INDEX(A A_X01) INDEX(B, B_X03) */ => O
	/*+ INDEX(A), INDEX(B) */ => X

	-- 스키마명까지 명시하면 안됨
	SELECT /*+ FULL(SCOTT.EMP) */ => X
	FROM EMP

	-- 테이블명 별칭으로 지정했으면 힌트절도 똑같이 해줘야 함
	SELECT /*+ FULL(EMP) */ => X
	  FROM EMP E	
	```
### 1.2 SQL 공유 및 재사용
+ 소프트 파싱(Soft Parsing)
	+ 기존에 **이미 생성된 실행 계획을 재사용**하는 방식이다. 
	+ 라이브러리 캐시(Library Cache)에 동일한 SQL이 존재하면 **최적화 과정을 생략하고 즉시 해당 SQL을 실행** 한다.
	+ 발생하는 경우
		+ 바인드 변수(Bind Variable)를 사용하여 SQL을 실행할 때
		+ SQL 실행 계획이 라이브러리 캐시에 남아 있는 경우
	+ 예시
	```sql
	-- 바인드 변수 사용으로 소프트 파싱 발생
	SELECT * FROM EMP E WHERE E.EMPNO = :EMPNO;
	```
+ 하드 파싱(Hard Parsing)
	+ **SQL을 처음 실행**하거나 **기존 실행 계획을 재사용할 수 없을 때** 사용하는 방식이다.
	+ 발생하는 경우
		+ 바인드 변수(Bind Variable)를 사용하지 않고 매번 새로운 SQL을 실행하는 경우
		+ 라이브러리 캐시가 가득 차서 이전 실행 계획이 삭제된 경우
	+ 예시
	```sql
	-- 바인드 변수 미사용으로 하드 파싱 발생
	SELECT * FROM EMP E WHERE E.EMPNO = 7900;
	```

![소프트파싱과 하드파싱 비교](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbHNZm6%2FbtrLvDSRSCK%2FX47ja3tlEyrByjXP69XAH1%2Fimg.png)

> 라이브러리 캐시(Library Cache)
> + SQL 실행 계획을 저장하는 메모리 영역이다.
> + SQL을 실행할 때 반복적인 하드 파싱을 줄이고 성능을 최적화 하기 위해 존재한다.

### 1.3 데이터 저장 구조 및 I/O 메커니즘
+ 시퀀셜 액세스 VS 랜덤 액세스
	+ 시퀀셜(Sequential) 액세스
		+ 물리적 또는 논리적으로 연결된 **순서에 따라 차례대로** 블록을 읽는 방식이다.
	+ 랜덤(Radom) 액세스
		+ 순차적이지 않고 **특정 위치에서 바로 접근** 해서 블록을 읽는 방식다.
+ Table Full Scan vs Index Range Scan
	+ Table Full Scan
		+ **시퀀셜 액세스**와 **Multiblock I/O 방식**으로 데이터를 읽는다.
		+ **순서에 따라 차례대로 한번에 인접한 수십~수백개의 데이터 블록을 읽는 방식**이다.
	+ Index Range Scan
		+ **랜덤 액세스**와 **Single Block I/O** 방식으로 데이터를 읽는다.
+ 데이터베이스 저장 구조
	+ 테이블스페이스(Tablespace)
		+ 데이터베이스의 논리적 저장 공간을 의미하며 여러 개의 세그먼트로 구성된다.
	+ 세그먼트(Segment)
		+ 테이블, 인덱스는 각각 하나의 세그먼트를 가지게 되며 여러 개의 익스텐트로 구성된다.
	+ 익스텐트(Extent)
		+ 세그먼트를 구성하는 물리적인 저장 단위이다.
		+ 익스텐트 크기는 자동으로 조정 할 수 있다.
		+ 하나의 익스텐트는 여러 개의 데이터 블록으로 구성된다.
	+ 데이터 블록(Data Block)
		+ 가장 작은 저장 단위 이다.
+ DB버퍼 캐시
	+ 데이터베이스가 디스크에서 읽어온 데이터를 메모리에 저장하는 공간을 말한다.
	+ 동일한 데이터를 다시 읽을 때 I/O를 줄이고 성능을 향상시키기 위해서 사용한다.
	+ LRU(Least Recently Used) 알고리즘을 사용한다.
---
## 2장 인덱스 기본
### 2.1 인덱스 구조 및 탐색
+ 테이블에서 데이터를 찾는 방법
	+ 테이블 전체를 스캔한다.
	+ 인덱스를 이용한다.
+ 인덱스 수직적 탐색 vs 인덱스 수평적 탐색
	+ 인덱스 수직적 탐색
		+ **조건에 맞는 첫번째 레코드를 찾는 과정**이다.
		+ 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.
	+ 인덱스 수평적 탐색
		+ **본격적으로 데이터를 찾는 과정**이다.
		+ 인덱스 리프 블록은 양방향 연결 리스트 구조여서 서로 앞뒤 블록에 대한 주소값을 가지고 있다.

### 2.2 인덱스 기본 사용법
+ **인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용 할 수 있다.**
+ 예를들어 "글로벌"로 시작하는 단어는 쉽게 찾을 수 있지만 중간에 "테이블"이라는 단어를 찾는 건 더 오래 걸린다.
+ 인덱스를 정상적으로 사용한다라는 것은 리프블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다.(=인덱스 Range Scan 방식)
+ 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용 할 수 없다.
	+ 인덱스 스캔 시작점을 찾을 수 없기 때문이다.
	```sql
	WHERE 날짜 BETWEEN '20250101' AND '20250131'
	- 인덱스 스캔 시작점 : 2025년 01월 01일

	WHERE SUBSTR(날짜, 5, 2) = '01'
	- 인덱스 스캔 시작점 : ?

	WHERE 이름 LIKE '%' || '대한' || '%'
	- 인덱스 스캔 시작점 : ?
	```
+ `OR조건`, `IN조건`은 기본적으로 인덱스 Range Scan이 불가능 하지만 옵티마이저가 인덱스 Range Scan으로 변환해준다.
### 2.3 인덱스 확장기능 사용법
+ 인덱스 스캔 방법
	+ Index Range Scan
		+ 인덱스 루트에서 리프 블록까지 **수직적으로 탐색한 후에 필요한 범위만 스캔**하는 방식이다.
	+ Index Full Scan
		+ 인덱스 리프 블록을 **처음부터 끝까지 수평적으로 스캔**하는 방식이다.
	+ Index Unique Scan
		+ **수직적 탐색**만으로 데이터를 찾는 방식이며 **`=` 조건으로 탐색하는 경우에 작동**한다.
	+ Index Skip Scan
		+ **복합 인덱스 선행 컬럼이 where조건에 없을때도 인덱스를 활용하는 방식**이다.
		+ 인덱스의 첫번째 컬럼의 고유한 값들을 그룹으로 나누어 검색한다.
		+ 선행 컬럼의 고유값이 적을 때 효과적이며 Table Full Scan을 방지 할 수 있다.
	+ Index Fast Full Scan
		+ 인덱슬르 전체적으로 읽으면서 데이터를 스캔하는 방식이다.
		+ 인덱스에 포함된 컬럼만 조회 가능하다.
		```sql
		-- EMP_NO 컬럼이 인덱스에 포함되어 있다면 Index Fast Full Scan 가능하다.
		SELECT EMP_NO FROM EMP;
		SELECT COUNT(*) FROM EMP WHERE EMP_NO > 100;
		```
+ ORDER BY절에서 자동 정렬
	+ 인덱스 : 장비번호 + 변경일자 + 변경순번
	```sql
	SELECT * 
	  FROM 상태변경이력 
	 WHERE 장비번호 = 'A001'
	ORDER BY 변경일자, 변경순번
	```
	+ ORDER BY를 안 해도 인덱스에 따라서 변경일자, 변경순번순이 된다.
+ SQL 성능은 그런데서 결정되는게 아니라 블록 I/O를 줄일수 있느냐 없느냐에서 결정된다.
---
## 3장 인덱스 튜닝
### 3.1 테이블 액세스 최소화
+ 인덱스 ROWID
	+ 우편번호와 같은것으로 다음 데이터를 가리키는 포인터가 아니다.
	+ ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고 못 찾을때만 디스크에서 블록을 읽는다.
+ 인덱스 손익분기점
	+ **Index Range Scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 지점**을 말한다.
### 3.2 부분범위 처리 활용
### 3.3 인덱스 스캔 효율화
### 3.4 인덱스 설계
